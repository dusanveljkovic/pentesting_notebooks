## Exploiting unrestricted file uploads to deploy a web shell
From a security perspective the worst possible scenario is when a website allows you to upload server-side scripts, and is also configured to execute them as code.
Sample php web shells:
```php
<?php echo file_get_contents('/path/to/target/file'); ?>
```
```php
<?php echo system($_GET['command']); ?>
```

## Exploiting flawed validation of file uploads
### Flawed file type validation
One way the websites may attemptt to validate file uploads is to check that the input specific [[Headers#Content type]] matches an expected [[MIME]] type. Problems can arise when the value of this header is implicitly trusted by the server. If no further validation is performed to check whether the contents of the file actually match the supposed [[MIME]] type this defense can be easily bypassed.

### Preventing file execution in user-accessible directories
This kind of configuration often differs between directories. If you can find a way to upload a script to a different directory that's not supposed to contain user-supplied files the server may execute your script after all.

### Insufficient blacklisting of dangerous file types
Bad blacklists can be bypassed by using lesser known alernative file extensions that may still be executable.

### Overriding the server configuration
In cases when a servers lets us upload files we can try to upload web config files and map an arbitrary custom file extension to an executable MIME type thus bypassing any validation.

### Obduscating file extensions
* Provide multiple extensions
* Add trailing character `exploit.php.`
* Try using URL encoding for dots, forward slashes, and backward slashes
* Add semicolons or URL-encoded null byte characters before the file extension.
* Try usingg multibyte unicode characters, which may be converted to null bytes and dots after unicode conversion or normalization.

### Flawed validation of the file's contents
Intead of implicitly trusting [[Headers#Content type]] specified in a request, more secure servers try to verify that the contents of the file actually match what is expected.
Using special tools such as `ExifTool` it can be trivial to create a polyglot JPEG file containing malicious code within its metadata.

### Exploiting file upload race conditions
Developers sometimes implement their own processing of file uploads independently of any framework. Not only is this fairly complex to do well it can also introduce race conditions that enable an attacker to completely bypass even the most robust validation.
This vulnerabilites are often extremely subtle, making them difficult to detect during blackbox testing.


